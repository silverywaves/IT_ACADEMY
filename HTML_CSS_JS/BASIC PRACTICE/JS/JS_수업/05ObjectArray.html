<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 배열 : 배열객체, 연속적인 공간 할당 -> 위치정보(인덱스)로 배열요소에 접근 가능 

        // 배열관련 함수(메서드)
        let arr = ['a', 'b', null, true, 30, 50.5, {owner:'홍길동', model:"벨로스터"}];
        // 배열의 마지막 요소는 객체와 마찬가지로 쉼표로 끝날 수 있음

        console.log(typeof arr);    // object
        console.log(arr[0]);        // [인덱스]
        console.log(arr[1]);
        console.log(arr[2]);
        console.log(arr[3]);
        console.log(arr[4]);
        console.log(arr[5]);
        console.log(arr[6]);
        console.log("\n");

        arr[4]=31;              // 요소 수정
        console.log(arr[4]);

        console.log("\n");
        console.log("-----------------------");
        console.log("\n");

        // JS 배열은 동적확장 가능
        console.log("size: " + arr.length);
        arr[7]=202;             // 요소 추가
        console.log("size: " + arr.length);
        arr[8]={name:'윤정한', age:30};
        console.log("size: " + arr.length);
        console.log("\n");

        // 요소탐색(반복문)
        for(i=0; i<arr.length; i++){      //  for(초기값; 조건식; 탈출연산){}
            console.log(arr[i]);
        }
        console.log("\n");
        console.log("\n");
        
        // 
        for(i in arr){
            console.log(arr[i]);
        }
        console.log("\n");
        console.log("-----------------------");
        console.log("\n");

        // 배열관련 메서드 PUSH() : 맨 끝에 요소 추가(여러개 가능)   - 스택
        console.log(arr,length);
        arr.push(1234);
        for(i in arr)
            console.log(arr[i])
        console.log(arr.length);

        console.log("\n");
        console.log("-----------------------");
        console.log("\n");

                // shift - 제일 앞 요소를 꺼내 제거한 뒤 남아있는 요소들을 앞으로 밀어줌
                //       - 제거한 요소의 다음번 요소가 첫번째 요소가 됨(여러개 가능)
                //       - push 와 다르게 요소이동->인덱스변경 이루어져 느림

        // 배열관련 메서드 POP() : 끝의 요소 빼냄   - 스택
        console.log(arr.length);
        arr.pop();
        for(i in arr)
            console.log(arr[i])
        console.log(arr.length);

        console.log("\n");
        console.log("-----------------------");
        console.log("\n");

                // unshift - 배열 앞 요소 추가
                //         - pop 와 다르게 요소이동->인덱스변경 이루어져 느림

        // 배열관련 메서드 FOREACH(로직) -- 순회메서드
        // 콜백함수 : 매개변수로 "함수 객체를 전달"해서 호출 함수 내에서 매개변수 함수를 실행하는 것
        // function(){} == ()=>{}
        // arr.forEach((요소)=>{처리되는 로직});
        arr.forEach((item) => {console.log(item);});

        console.log("\n");
        console.log("-----------------------");
        console.log("\n");

        // 배열관련메서드 SORT : 정렬 -- 콜백함수
        let arr2 = ["최승철", "김민규", "윤정한"];
        let arr3 = [3, 55, 2, 10, "1", 42, 98, 39];
        
        arr2.sort();    // 기본 sort함수는 요소를 문자열로 변환 후
                        // 사전 편찬 순서대로 오름차순 정렬
        arr2.forEach(item=>console.log(item));  // 라인이 하나면 (), {} 생략 가능

        console.log("\n");
        console.log("-----------------------");
        console.log("\n");

        arr3.sort();    // 사전편찬순서대로라 1 10 2 3 ... 이렇게 정렬됨
        
        arr3.sort((a,b)=>{     // 사전 편차 순서 말고 일반순서대로 정렬하기
            // return a-b;     // 오름차순 정렬
            return b-a;        // 내림차순 정렬
        })
        arr3.forEach(item=>console.log(item));

        console.log("\n");
        console.log("-----------------------");
        console.log("\n");

        // 배열관련 메서드 FILTER
        // 조건식을 만족하는 요소만 필터링해서 따로 배열에 저장
        let arr4 = [null, 1, 55, 2.9, {name:'박은태', job:"뮤지컬배우"}, 180, false, "g1", 42, 't1', 39, true, {name:'홍지수', age:30}];
        // arr4.filter((요소)=>{return 조건식}) or arr4.filter(요소=>조건식)
        let filteredArr = arr4.filter(item=>typeof item == 'boolean');   // object, boolean, string, number 등 바꿔서 적용
        filteredArr.forEach(item=>console.log(item));

        console.log("\n");
        console.log("-----------------------");
        console.log("\n");

        // 메서드 체인 : 메스드가 객체를 반환하면 반환한 객체의 메서드를 호출할 수 있음
        //              -> 메서드를 마침표 연산자를 통해 계속 연결해서 실행
        let FA = arr4.filter(item=>typeof item == "number")
                     .sort((a,b)=>a-b)
                     .forEach(item=>console.log(item));
        // FA.forEach(item=>console.log(item));

        console.log("\n");
        console.log("-----------------------");
        console.log("\n");

        // 배열관련 메서드 REDUCE : 누적
        // reduce((누산변수:sum 등, 요소변수)=>{return 연산로직}, 누산변수초기값)
        let returnVal = arr4.filter(item=>typeof item == "number")
                            .reduce((sum, item)=>{
                                console.log(sum);
                                return sum+item;
                            }, 0)
        console.log("RV : " + returnVal);

        console.log("\n");
        console.log("-----------------------");
        console.log("\n");


        // 배열 객체 반복하기 [{}, {}, {}, {}];
        let arr6 = [
            {name:"정선아", age:"39", roll:"미나"},
            {name:"윤공주", age:"40", roll:"아이다"},
            {name:"김소현", age:"43", roll:"엘리자벳"},
            {name:"차지연", age:"45", roll:"마타하리"}
        ];
        arr6.forEach((item)=>{      // 오브젝트에서는 필터 사용 불가 (배열에서만 사용가능)
            // console.log(item);
            for(key in item){
                // console.log(key);
                if(key == 'name' || key == 'roll')
                    console.log(item[key]);
            }
            console.log("-----------------------");
        })  


        console.log("\n");
        console.log("-----------------------");
        console.log("\n");


        // MAP() : 함수의 반환값으로 새로운 배열 생성
        // Filter vs Map
        // Filter : 조건식의 true 반환하면 요소 유지, false 반환하면 버림 -> true  값만 가지고 배열 만듦
        // Map : 여러 산술된 인자(return 결과값 자체)를 받아 배열로 만듦 - 조건식도 포함
        let arr7 = [10, 20, 30, 40, 50];
        let RA_01 = arr7.map((item)=>{return item+"%";});
        RA_01.forEach(item=>console.log(item));

        console.log("\n");
        console.log("-----------------------");
        console.log("\n");

        let arr8 = [
            {name:"정선아", age:"39", roll:"미나"},
            {name:"윤공주", age:"40", roll:"아이다"},
            {name:"김소현", age:"43", roll:"엘리자벳"},
            {name:"차지연", age:"45", roll:"마타하리"}
        ];
        let RA_02 = arr8.map((item)=>{
            return {name:item.name, roll:item.roll};
        });
        RA_02.forEach(item=>console.log(item));

        // 중요 메서드 재정리!
        // forEach((item)=>{logic})
        // filter((item)=>{condition})
        // map((item)=>{logic})
        // reduce((누산변수, item)=>{logic}, 누산변수초기값)
        
        console.log("\n");
        console.log("\n");
        console.log("-----------------------");
        console.log("\n");
        console.log("\n");

        // 유사배열 - {}.forEach (x), filter (x)
        //           {}.map{x}, reduce{x}...
        // 유사배열은 배열처럼 보이지만 사실 key 가 숫자, length 값을 가지고 있는 객체
        const sim_arr = {  
            0:'aaa',
            1:'bbb',
            2:'ccc',
            3:'ddd',
            length : 4
        };
        console.log(sim_arr.length);
        console.log(sim_arr[0]); console.log(sim_arr[3]);

        console.log("\n");
        console.log("-----------------------");
        console.log("\n");

        Array.from(sim_arr).forEach(item=>console.log(item));   // 배열로 바꿔준 뒤 사용가능

        // sim_arr.forEach(item => {
        //     console.log(item);
        // })

    </script>
</body>
</html>