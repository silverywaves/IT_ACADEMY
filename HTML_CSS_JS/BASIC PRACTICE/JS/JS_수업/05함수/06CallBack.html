<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 콜백함수(Call Back) CallBackFunc(로직, 인자){}
        // call - 함수 실행 / back - 뒤에  =>  내가 실행하는 것이 아님. 내가 로직을 전달하면 함수가 받아 처리함
        // 함수를 호출하는 시점이 바뀌어진 형태의 함수
        // 기존 방식 : 사용자(개발자)가 함수를 직접 정의 -> 정의된 함수를 호출(Call)하여 결과를 받환받는 방식
        // CallBack : 콜백함수의 인자로 수행로직(()=>{}, function(){})을 전달하여 콜백함수로부터 처리된 결과를 반환받는 형태
        
        // function func(n1, n2){
        //     const result = n1+n2;
        //     return result;
        // }
        // const r = func(10,20); // Call
        // console.log(r);

        // function callbackFunc(n1,n2,func){
        //     const result = func(n1,n2);
        //     return result;
        // }
        // function sum(n1,n2){return n1+n2};
        // function sub(n1,n2){return n1-n2};
        // function mul(n1,n2){return n1*n2};
        // function div(n1,n2){return n1/n2};

        // const r1 = callbackFunc(20,4,sum);  // sum 위치전달 
        // console.log(r1);
        // const r2 = callbackFunc(20,4,sub);
        // console.log(r2);
        // const r3 = callbackFunc(20,4,mul);
        // console.log(r3);
        // const r4 = callbackFunc(20,4,div); 
        // console.log(r4);

        const data = [11, 20, 41,  15, 7, 1, 51];

        function simForEach(data, func){
            // 오름차순 정렬 후(버블정렬)
            // var length = data.length;
            // var i, j, temp;
            //     for (i = 0; i < length - 1; i++) {          // 순차적으로 비교하기 위한 반복문
            //         for (j = 0; j < length - 1 - i; j++) {  // 끝까지 돌았을 때 다시 처음부터 비교하기 위한 반복문
            //         if (data[j] > data[j + 1]) {            // 두 수를 비교하여 앞 수가 뒷 수보다 크면
            //             temp = data[j];                     // 두 수를 서로 바꿔준다
            //             data[j] = data[j + 1];
            //             data[j + 1] = temp;
            //             }
            //         }
            //     }
            
            // 내림차순
            const val = data.sort((a,b)=>{return b-a;}) // a-b : 오름차순
                .reduce((sum,item)=>{return sum+item},0)
            console.log(data);
            console.log(val);
            data.push(val);         // 누산처리 결과 마지막에 출력
            for(idx in data){
                func(data[idx]);
            }
        }

        simForEach(data, (item)=>{
            console.log(item);
        });

        // Q.
        function callbackfunc(func1, func2, func3,...args){
            const arr1 = func1(args);   // 가변인자를 받아서 그 배열요소 중 숫자만 필터링된 배열 반환
            console.log("숫자필터링된 배열 : " + arr1);
            const arr2 = func2(arr1);   // 숫자만 필터링된 배열 중 짝수만 걸러서 배열로 반환
            console.log("짝수만 필터링된 배열 : " + arr2);
            const arr3 = func3(arr2);   // 짝수로 걸러진 배열의 합 반환
            return arr3;
        }
        function proc1(arr){return arr.filter((item)=>typeof item=='number')}
        function proc2(arr){return arr.filter((item)=>item%2==0)}      
        function proc3(arr){return arr.reduce((sum,item)=>sum+item,0)}  // 짝수의 합 반환

        const rVal = callbackfunc(proc1,proc2,proc3, 10, 20, 'ture', 11, 152, 999, 24, '문자열', null, 155, 24);
        console.log('rVal : ', rVal);
</script>
</body>
</html>