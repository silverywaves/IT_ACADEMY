# 정처산기 실기 정리
운영체제 세대별 발달 과정
---
> 1세대
- 일괄 처리 시스템(Batch Processing System) → *가장 먼저 생겨난 방식*
  - 유사한 성격의 작업을 **한꺼번**에 모아서 처리
  - 일정량 또는 일정 기간동안 모음

<br>

> 2세대
- 다중 프로그래밍(Multi Programming) → *처리량의 극대화*
  - 한 대 컴퓨터, 하나의 주기억장치, 여러 프로그램들 실행
    - 여러 개의 프로그램을 준비 상태에 두고 관리
    - 실행할 프로그램을 선정하기 위해 기억장치 관리 기법이나 CPu 스케줄링 기법 필요

- 시분할 시스템(Time Sharing System) → *응답시간의 최소화*
  - 여러 명의 사용자가 사용하는 시스템에서 컴퓨터가 사용자들의 프로그램을 **번갈아 가며 처리**해줌으로서 **각 사용자가 각자 독립된 컴퓨터를 사용하는 느낌**을 주는 시스템
  - CPU 전체 사용 시간을 작은 **작업 시간량(Time Slice)로 나누어서** 그 시간량 동안만 번갈아가면서 CPU 할당

- 다중 프로세싱(Multi Processing)
  - 한 대의 컴퓨터에 중앙처리장치(CPU)가 2개 이상 설치, 여러 프로그램들 실행
    - 프로세스를 여러 개 사용하므로 프로세서 중 일부에 문제가 발생하더라도 다른 프로세서를 이용해 처리 가능

- 실시간 시스템(Real-Time System)
  - 한정된 시간 제약조건에서 자료를 분석하여 처리
    - ex) 비행기 제어 시스템, 교통 제어

<br>

> 3세대
- 다중 모드(Mode) 시스템
  - 1, 2세대 혼합 시스템

<br>

> 4세대
- 분산 처리 시스템(Distributed Processing System)
  - 여러 대의 컴퓨터들에 의해 작업들을 나누어 처리
    - 그 내용이나 결과를 **통신망을 이용하여 상호 교환**
   
<br>

NAT(Network Address Translation, 네트워크 주소 변환)
---
- **사내의 개별 주소(사설 IP)** 와 **정식 IP 주소(공인 IP)** 를 상호 변환하는 기능

- NAT 사용 이유
  - **사설 네트워크에 속한 여러 개의 호스트가 하나의 공인 IP 주소를 사용**하여 인텉넷에 접속하기 위함
    - 공인 IP 절약, 외부 침입에 대한 보안성 높이는 기술

<br>

회복
---
- *commit*
  - **트랜잭션이 정상적으로 수행**하여 변경된 내용을 실제 물리적 디스크에 **저장**할 때 사용되는 연산

- *rollback*
  - **트랜잭션의 실행이 비정상적**임을 알리는 연산자
  - 트랜잭션이 수행한 결과를 원래의 상태로 원상 **복귀** 시키는 연산

<br>

퀵 정렬(Quick Sort)
---
- **기준점(Pivot, 피벗)**을 기준으로 좌우를 비교하여 정렬하는 방법

<br>

관계 대수 연산자
---
- SELECT(σ)
  - 릴레이션에서 주어진 조건을 만족하는 **튜플들을 검색**하는 것
  - 그리스 문자의 시그마(σ) 이용
  - 행, 수평적 연산

- PROJECT(π)
  - 릴레이션에서 주어진 조건을 만족하는 **속성들을 검색**하는 것
  - 그리스 문자의 파이(π) 이용
  - 열, 수직적 연산
 
- 교집합(∩, Intersection)
  - 두 릴레이션에 존재하는 튜플의 **교집합**을 구하는 연산

- 차집합(-, Difference)
  - 두 릴레이션에 존재하는 튜플의 **차집합**을 구하는 연산

<br>

네트워크 프로토콜
---
- TCP(Transmission Control Protocol, 전송 제어 프로토콜)
  - IP 프로토콜 위에서 **연결형 서비스**를 지원하는 **프로토콜(Protocol)**
    - 인터넷 환경에서 기본으로 사용

  - 데이터를 **세그먼트(Segment)**라는 블록 단위로 분할해 전송
    - 전이중(Full Duplex) 방식의 **양방향 가상 회선**을 제공
      - **신뢰성**있는 데이터 전송 보장

  - **흐름 제어** 기능과 **혼잡 제어** 기능 지원
    - 네트워크에서의 **데이터 전달 통제(Transmission Control)**가 가능한 프로토콜

```
    - 가상 회선 연결 형태 → 신뢰성(안정성)↑
    - 패킷의 다중화, 순서 제어, 오류 제어, 흐름 제어 기능
```

<br>

애플리케이션 테스트
---
- bigbang
  - **한 번에 모든 모듈을 한꺼번에 통합**하여 테스팅하는 방법
  - 주로 실제 개발된 모듈을 통합하여 테스트
  - 소규모 프로그램이나 프로그램의 일부를 대상으로 하는 경우가 많음
    - 절차가 간단하고 쉬움
  - 오류가 발생했을 때 어떤 모듈에서 오류가 존재하고 그 원인이 무엇인지 찾기 어려움

<br>

IPv4 헤더 구조
---
|-|
|-|
|![image](https://github.com/user-attachments/assets/4dc85709-81e4-4ee3-8bcd-91608b0c798d)|

- 크기
  - 기본 20Byte
  - 옵션(0~40Byte)에 따라 60Byte까지 확장 가능
- 구성
  - 버전(Version, Version Number) : IP 프로토콜의 **버전 번호**(IPv4의 경우 4) - 4bits
  - 헤더 길이(Header Length, HLEN) : **헤더의 크기**(최대 60Byte) - 4bits
  - 서비스 품질(Type of Service, ToS) : 처리량, 전달 지연, 우선순위 등 - 8bits
  - 패킷 길이(Total Packet Length) : IP 헤더와 데이터를 포함한 **IP 패킷 전체 길이** - 16bits
  - 식별자(Fragment Identifier) : 각 조각의 **일련번호**(동일한 데이터그램에 속하면 같은 일련번호 공유) - 16bits
  - 플래그(Fragment Flag) : 조각의 **특성** - 3bits
  - 오프셋(Fragment Offset) : 조각나기 전 원래 **데이터그램의 위치** - 13bits
  - 수명(Time To Live, TTL) : IP 패킷의 **생존 시간** - 8bits
  - 프로토콜 식별자(Protocol Identifier) : 서비스를 제공할 대상이 되는 **상위 계층의 프로토콜 식별자** - 8bits
  - 헤더 체크섬(Header Checksum) : 헤더에 대한 **오류 검출** - 16bits
  - 송신자 IP 주소(Source IP Address) - 32bits
  - 수신자 IP 주소(Destination IP Address) - 32bits

<Br>

서브네팅(Subnettind)
---
- 서브넷(Subnet)
  - B클래스를 어느 기업체에게 할당했을 경우 65,000여개의 IP를 다 쓰는 것이 아니라 10,000개 정도만 쓴다고 가정
    - 남은 55,000개의 IP는 쓰이지 않은 채 이 기업은 B 클래스 하나를 점유하고 있는상태
      - 비효율적

- 정의
  - IP 주소에서 네트워크 영역을 부분적으로 나눈 부분망

- 서브네팅
  - 할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용하는 것

- 서브넷 마스크(Subnet Mask)
  - IP 주소에서 **네트워크 주소와 호스트 주소를 구별**하는 방식(클래스마다 다름)
    - 4Byte(32bit)의 IP 주소 중 *네트워크 주소*와 *호스트 주소*를 구분하기 위한 비트

|클래스|서브넷 마스크|시작주소|
|:-:|:-:|:-:|
|A 클래스 서브넷 마스크|255.0.0.0|0 ~ 127|
|B 클래스 서브넷 마스크|255.255.0.0|128 ~ 191|
|C 클래스 서브넷 마스크|255.255.255.0|192 ~ 223|

- 서브넷 마스크 사용법
  - IP 주소 : 191.168.25.0 → B 클래스
  - 서브넷 마스크 : 255.255.252.0

```
  B 클래스 기본 서브넷 마스크 : 11111111 . 11111111 . 00000000 . 00000000
         문제의 서브넷 마스크 : 11111111 . 11111111 . 11111100 . 00000000
                                            네트워크 개수 = 2의6승 = 64개
                                          네트워크 ID : 0000000 ~ 1111111 
```

- IP 주소와 Subnet Mask 를 AND 연산을 수행하여 **네트워크 주소**를 얻음

```
        10111111 . 10101000 . 00011001 . 00000000
  AND   11111111 . 11111111 . 11111100 . 00000000
  --------------------------------------------------
        10111111 . 10101000 . 000110/00 . 00000000
      191.168.24.0 : 네트워크 주소(22bit) / 호스트 주소(10bit)
```

- 특수 용도로 사용하는 IP 주소
  - 네트워크 주소 : 첫 IP 주소
  - 브로드캐스트 주소 : 마지막 IP 주소
    - ex) 7번째 네트워크의 브로드캐스트 주소 : 192.168.27.255

<br>

> IP 주소가 '191.168.25.0'이고, 서브넷 마스크가 '255.255.255.0'일 때, 네트워크 주소와 브로드캐스트 주소는?
```
  네트워크 주소 : 191.168.24.0

  브로드캐스트 주소 : 191.168.27.255
```

<br>

데이터 링크 계층
---
- 흐름 제어
  - 한 번에 전송할 수 있는 데이터의 양 제어
  - 연속으로 프레임을 전송할 때 수신 여부 확인 기능 수행

- 프레임의 동기화
  - 프레임의 헤더에는 수신 측에 프레임이 도착했음을 알리는 비트 존재
  - 트레일러에는 에러를 제어하는 비트와 프레임의 끝을 나타내는 비트 존재

- 오류 제어
  - 체크섬 등의 오류 검출 기능과 오류 정정 기능 수행
  - 오류가 발생한 경우 프레임의 재전송 요구 가능

- 에러검출 및 정정

- 순서 제어(HDLC, LAPB, LLC, MAC, LAPD, PPP)
  - 데이터를 순차적으로 전송하기 위해 프레임 번호 부여 기능 수행
  - 수신 노드에 식별 번호를 추가하여 프레임의 순서 제어

<br>

교착상태 필요 충분 조건
---
- 교착 상태(Dead Lock)
  - 예측 못한 다운
  - 상호 배제에 의해 나타나는 문제점
  - 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 **무한정 기다리는 현상**

- 교착상태 발생 4가지 필요충분조건(동시 만족시 발생)
  - 상호배제(Mutual Exclusion)
    - **한 번에 한 개의 프로세스**만이 공유 자원을 사용할 수 있어야 함
    - 프로세스들이 필요로 하는 자원에 대해 **배타적인 통제권을 요구**

  - 점유와 대기(Hold & Wait)
    - 최소한 하나의 자원을 점유하고 있으면서 **다른 프로세스에 할당되어 사용되고 있는 자원**을 추가로 점유하기 위해 **대기**하는 프로세스가 있어야 함

  - 비선점(Nonpreemption)
    - 프로세스에 할당된 자원은 사용이 끝날 때까지 **강제로 빼앗을 수 없음**

  - 환형대기(Circular Wait, 순환대기, 원형대기)
    - 공유 자원과 공유 자원을 사용하기 위해 대기하는 프로세스들이 **원형**으로 구성되어있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 함
    - 각 프로세스는 **순환적**으로 다음 프로세스가 요구하는 자원을 가지고 있음
   
<br>

DBMS 구성(데이터베이스 질의 처리기)
---
|-|
|-|
|![image](https://github.com/user-attachments/assets/0bae0519-9ef9-4ef9-bca8-6d400095a84d)|

- 질의어 처리기
  - **사용자의 데이터 처리 요구를 해석하여 처리**하는 역할을 담당하고 있는 요소

- DML 컴파일러
  - **DML**로 작성된 데이터의 처리(삽입, 삭제, 수정, 검색) 요구를 분석하여 런타임 데이터베이스 처리기가 이해할 수 있도록 해석하는 요소
  - DML 명령어를 컴파일하여 목적 코드를 생성하는 요소

- DDL 컴파일러
  - **DDL**로 명세된 정의를 데이터 사전(시스템 카탈로그)에 저장

- 트랜잭션 관리자
  - 데이터베이스에 접근하는 과정에서 사용자의 **접근 권한**이 유효한지를 검사
  - 데이터베이스 **무결성**을 유지하기 위한 **제약조건** 위반 여부 확인
  - **회복**이나 **병행 수행**과 관련된 작업도 담당하는 요소

- 런타임 데이터베이스 처리기
  - **저장 데이터 관리자를 통해 데이터베이스에 접근하여**, DML 컴파일러로부터 전달받은 데이터 처리 요구를 **데이터베이스에서 실제로 실행하는 요소**

- 저장 데이터 관리자
  - 디스크에 저장되어 있는 **데이터 사전(시스템 카탈로그)와 사용자 데이터베이스를 관리**하고, 여기에 실제로 접근하는 역할을 하는 요소

<br>

SQL : CREATE TABLE문(CHECK, IN)
---
- COMPANY 테이블을 생성하는 SQL문
  - COMPANY 테이블의 TITLE 속성에는 Intern, Staff, Manager, Director, President 값만 허용

```
  CREATE TABLE COMPANY (
        ID INT NOT NULL,
        NAME VARCHAR(20) NOT NULL,
        AGE INT NOT NULL,
        TITLE VARCHAR(20) CHECK(TITLE IN('Intern', 'Staff', 'Manager', 'Director', 'President'))
  );
```
- CHECK : 특정 속성이 입력 가능한 값의 범위를 지정
- IN (조건1, 조건2, ...) : 조건1 또는 조건2, ... 에 일치하는 경우

<BR>

