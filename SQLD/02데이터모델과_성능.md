## 데이터 모델과 성능
### 01. 성능 데이터 모델링
#### 정의
  - 데이터 베이스 성능을 고려하여 데이터 모델링을 수행하는 것
    - 정규화, 반정규화, 테이블 통합 및 분할, 조인구조, PK/FK 설정 등


#### 수행 시점
  - 빠를수록 좋음
    - 분석/설계 단계에서 성능 모델링 수행 -> 재업무 비용 최소화

  - 일반적인 경우
    - 대충 설계 -> 성능 저하 -> 해당 부분만 SQL 튜닝


#### 성능 데이터 모델링 진행 순서
  - 정규화를 정확하게 수행
    - 주요 관심사별로 테이블을 분산
   
  - 데이터베이스 용량산정 수행
    - 각 엔터티에 어느정도의 트랜잭션이 들어오는지 파악
   
  - 데이터베이스에 발생되는 트랜잭션의 유형 파악
    - CRUD 매트릭스 활용
   
  - 용량과 트랜잭션의 유형에 따라 반정규화 수행
    - 반정규화 : 정규화의 반대방향에 해당하는 일을 수행하는 것
    - 테이블, 속성, 관계 변경
   
  - 이력모델의 조정, 인덱스를 고려한 PK/FK의 순서 조정, 슈퍼타입/서브타입 조정 등 수행
    - 성능 관점에서 데이터 모델 최종 검증


---

### 02. 관계형 데이터베이스
#### DBNS의 발전
  - 1960년대
    - Flowchart 중심의 개발 방법 사용
    - **파일구조**를 통해 데이터를 저장하고 관리
   
  - 1970년대
    - 데이터베이스 관리 기법이 처음 출현
    - **계층형(Hierarchical), 망형(Network)** 데이터베이스 제품 상용화
   
  - 1980년대
    - **관계형(Relational)** 데이터베이스 상용화
    - Oracle, Sybase, DB2 등의 제품 사용
   
  - 1990년대
    - Oracle, Sybase, Informix, DB2, Teradata, SQL Server 의 많은 제품 출현
    - **객체 관계형** 데이터베이스 발전
   

#### 관계형 데이터베이스
  - 1970년 영국의 수학자인 E.F Codd 박사의 논문에서 제안 -> 1980년대 상용화
    
  - 기업의 핵심 데이터는 대부분 관계형 데이터베이스로 저장
    
  - 관계형 데이터베이스는 SQL 문장에 의해 관리됨
 
![관계형데이터베이스](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/7fda56e6-8306-4cc8-9a8b-d509e3113131)



#### 개요
  - 테이블
 

    ![테이블1](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/23b0fc0e-20ed-45c7-8c39-651ee97254e2)



![테이블2](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/b7215826-1d5c-47fa-8e52-1ba2dca8efb7)



---

### 03. Relational Model Constraints
#### 도메인 제약(Domain Constraints)
  - 속성(Attribute)에 대한 제약
  - 속성 값은 원자성(atomicity-더이상 쪼개질 수 없음)을 가지며, 도메인에서 정의된 값이어야 함
  - Composite Attribute와 Multivalued Attribute는 허용되지 않음
    - cf) 주소 = 시군구 + 상세주소
  - Null 값은 허용(Not Null이 아닌 경우)
 
![도메인 제약](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/759e1737-a1fc-40a9-85ad-f6b7f1021a78)




   
#### 키 제약(Key Constraints)
  - 릴레이션(Relation)에 대한 제약
  - 릴레이션의 모든 튜플(Tuples)은 서로 식별 가능해야 함(=테이블은 키를 가져야 한다)
  - cf) Super Key, Candidate Key, Primary Key
    : Super Key 중에서 최소성을 갖는 것이 Candidate Key, Candidate Key에서 대표성을 갖는 것이 Primary Key
  - Q) 다음 중 키 제약을 위반하고 있는 릴레이션은?


![기본키 제약](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/aebc5021-f54d-40ca-a060-6449fff22982)



   
#### **개체 무결성 제약**(Entity Integrity Constraints)
  - 기본키(Primary Key)에 대한 제약
  - 기본키는 NOT NULL & UNIQUE 이어야 함
  - Q) 다음 중 개체 무결성 제약에 위배되지 않는 튜플은?


![개체무결성 제약](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/f084e7ef-ac8a-4b52-bd86-a6e054094351)



   
#### **참조 무경설 제약**(Referential Integrity Constraints)
  - 외래키(Foreign Key)에 대한 제약
    - 릴레이션 R1이 릴레이션 R2를 참조하는 경우, R2의 기본키는 R1에서 외래키로 사용됨
    - FK는 자기 자신이 속한 릴레이션을 참조할 수도 있음

  - 릴레이션 R1이 릴레이션 R2를 참조하는 경우, R1의 FK는
    - Null 이거나
    - Null 이 아닌 경우 R2에 실제로 존재하는 값으로 구성되어야 함

  - Q) 다음 중 참조 무결성을 위배하는 튜플은?


![참조무결성제약](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/f4c3d3bf-f3d2-4ae0-ae39-bd49b7f602e1)


---

### 04. 정규화와 성능
#### 이상현상(Anomaly)
DB 설계를 잘못했기 때문에 발생

  - 삭제 이상(delete anomaly)
    - 어떤 정보를 삭제하면서, 의도치않게 다른 정보도 함께 삭제되는 경우
    - '1102' 학생이 'A01'을 수강한 기록을 삭제할 때
      
  - 삽입 이상(insert anomaly)
    - 필수 정보가 비어있기 때문에 원하는 정보를 입력하지 못하는 현상
    - (1004, 윤정한, 010-4444-5555)인 학생을 추가하고자 할 때 -> 과목코드 정보가 없음
      
  - 갱신 이상(update anomaly)
    - 정보를 갱신할 때 여러개를 바꿔야 하는 현상 -> 공간 낭비, 시간 낭비
    - '1101' 학생의 연락처가 변경된 경우 -> 테이블을 분리해두었으면 한번만 변경하면 되지만, 아래 테이블에선 3번이나 변경해야함

      
![이상현상](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/f6fe2dfc-5c25-4d75-8134-d43f176df187)


#### 정규화(Normalization)
  - 목적 : 삽입/삭제/갱신 이상현상 방지
    
  - 함수적 종속성(FD, Functional Dependency)에 기반

  - 종류
    - NF(Normal Form, 정규형) : 정규화의 결과로 나오는 것
    - 1NF : 모든 값이 원자값을 가짐
    - 2NF : 부분함수종속(빨간색-PK가 복합키일때만 있을 가능성 있음) 제거
    - 3NF : 이행함수종속(초록색-PK가 아닌 항목이 화살표 쏘는 것) 제거 
    => 식별자가 아닌 속성(주식별자의 일부-부분함수종속 또는 일반속성-이행함수종속)이
        결정자(화살표출발지) 역할을 하는 함수 종속(화살표도착지) 제거 -> 3NF


![함수적 종속성](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/c2fbadec-88e7-4168-b369-b415048e4fe7)



#### 정규화의 효과
  - 데이터 중복 감소 -> 성능 향상
 
  - 데이터가 관심사별로 묶임 -> 성능 향상
 
  - 조회 징의에서 조인이 많이 발생 -> 성능 저하

  => 정규화를 통해 일반적으로 성능이 향상되나, 조회의 경우 처리 조건에 따라 성능이 향상되거나 저하됨



![정규화 효과](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/62502d1e-6b60-4bca-9cdc-5199886ac88b)



#### 정규화를 통한 성능 개선 예
  - 특정 학생의 학년 변경시
    - 정규화 전 : 해당 학생이 수강 테이블에서 나타나는 수만큼 변경
    - 정규화 후 : 해당 학생의 학년 한 건만 변경

  - 3학년 학생의 학번, 이름 조회시
    - 정규화 전 : 수강 이력이 누적된 수만큼 인스턴스 조회
    - 정규화 후 : 학생 수만큼 인스턴스 조회(성능 향상)

  - 학번, 학생명, 과목명, 평점 조회시
    - 정규화 전 : 하나의 테이블에서 모두 조회
    - 정규화 후 : 조인 필요(약간의 성능 저하)
   
![정규화 예](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/779d9762-a7a4-47b2-b757-59406aafaae0)


---

### 05. 반정규화와 성능
#### 반정규화의 정의
  - 반정규화(=역정규화 =Denormalization)
    
  - 정규화된 엔터티, 속성, 관계에 대해 성능 향상을 목적으로 중복, 통합, 분리를 수행하는 데이터 모델링 기법
    - cf) 비정규화 : 정규화를 아예 수행하지 않음 (정규화 <-> 비정규화)


#### 반정규화의 특징
  - 테이블, 칼럼, 관계의 반정규화를 종합적으로 고려해야 함
    - 일반적으로 속성(칼럼)의 중복을 시도함

  - 과도한 반정규화 -> 데이터 무결성 침해


![반정규화 특징](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/de31e161-1f76-486d-abc0-e3053752f0c3)



#### 반정규화의 사전 절차
1. 반정규화 대상조사
   - 범위처리빈도수 조사
   - 대량의 범위 처리 조사
   - 통계성 프로세스 조사
   - 테이블 조인 개수
  
2. 다른 방법 유도 검토
   - 뷰(VIEW) 테이블
   - 클러스터링 적용
   - 인덱스의 조정
   - 응용애플리케이션
  
3. 반정규화 적용
   - 테이블 반정규화
   - 속성의 반정규화
   - 관계의 반정규화

```
  - 다른 방법 유도
    - 뷰(View) 생성 : 뷰 자체가 성능 향상을 가져오지는 않음.
      - 신중하게 설계된 뷰를 재사용할 때 성능 향상
  
    - 클러스터링 : 자주 사용되는 테이블의 데이터를 디스크의 같은 블록에 저장
  
    - 인덱스의 조정 : 인덱스 추가, 삭제 및 순서 조정
  
    - 응용 애플리케이션 : 데이터 처리를 위한 로직 변경
```


#### 반정규화 기법
1. 칼럼 반정규화
  - 중복칼럼 추가
    - 조인 횟수를 감소시키기 위해, 다른 테이블의 칼럼을 중복으로 저장
    - ex) 각 사원의 이름과 소속지점명을 조회하는 질의가 많은 경우
      
  - 파생칼럼 추가
    - 값의 계산으로 인한 시간 지연을 줄이기 위해, 예상되는 값을 미리 계산하여 중복으로 저장(Derived Attribute)
    - 칼럼에 의한 파생
      - 행간의 순서가 바뀌어도 하위 칼럼값이 바뀌지 않음
    - 로우에 의한 파생
      - 특정 로우가 변경되면 모든 로우값 다시 계산 -> 가급적 사용 X
      
  - 이력테이블칼럼 추가
    - 대량 이력 데이터 처리의 성능 향상을 위해 종료 여부, 최근값 여부 등의 칼럼을 추가로 저장
    - ex) 직원이 가장 최근 등록한 차량을 조회하는 경우
      
  - PK의 의미적 분리를 위한 칼럼 추가
    - PK가 복합 의미를 갖는 경우 구성 요소 값의 조회 성능 향상을 위해 일반 속성 추가
    - ex) 차량번호가 '지역' + '일련번호' 로 구성된 경우 '지역' 일반속성 추가
      
  - 데이터 복구를 위한 칼럼 추가
    - 사용자의 실수 또는 응용프로그램 오류로 인해 데이터가 잘못 처리된 경우, 원래 값으로의 복구를 위해 이전 데이터를 임시적으로 중복 저장
    - ex) 고객 정보 중 이전 주소 추가


2. 테이블 반정규화
  - 테이블 병합
    - 관계 병합
      - 1:1 또는 1:M 관계를 병합
      - ex) 두 테이블의 동시 조회가 많은 경우
        
    - 슈퍼/서브타입 병합
      - 슈퍼/서브타입 관계를 병합 (one to one type -> single type/plus type)
        - Super Type : 여러 엔터티의 공통 속성
        - Sub Type   : 개별 속성
        - One to One Type : 개별 접근(1:1) 트랜잭션이 많은 경우
        - Plus Type       : 슈퍼타입+서브타입 접근 트랜잭션이 많은 경우
        - Single Type     : 여러 서브타입에 대한 동시 접근(All in One)이 많은 경우
          
      - 일반화(Generalization) 관계를 표현
     
      - 데이터의 양 및 트랜잭션의 유형에 따라 테이블 구조 결정

![슈퍼서브타입 모델 변환](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/6f4497e9-1c29-4b62-b7d3-fe9eda8db130)




  - 테이블 분할
    - 수직 분할
      - 디스크 I/O의 분산을 위해 테이블을 칼럼(Column) 단위로 분리
        
    - 수평 분할
      - 디스크 I/O의 분산을 위해 테이블을 로우(Row) 단위로 분리

      
  - 테이블 추가
    - 중복 테이블 추가
      - 원격 조인(다른 업무 또는 다른 서버 간 조인)을 제거하기 위해 동일한 테이블 구조 중복(분산 DB 참고)
        
    - 통계 테이블 추가
      - SUM, AVG 등의 통계값을 미리 계산하여 저장(분산 DB 참고)
        
    - 이력 테이블 추가
      - 이력 테이블 중 일부 레코드를 마스터 테이블에서 중복 관리
        
    - 부분 테이블 추가
      - 하나의 테이블에서 집중적으로 이용되는 칼럼들만 추출하여 별도의 테이블 생성
      - 테이블 수직 분할과 유사하지만, 원본 테이블을 유지하면서 추가함


  - 관계 반정규화
    - 중복관계 추가



