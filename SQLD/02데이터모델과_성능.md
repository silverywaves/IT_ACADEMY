## 데이터 모델과 성능
### 01. 성능 데이터 모델링
- 정의
  - 데이터 베이스 성능을 고려하여 데이터 모델링을 수행하는 것
    - 정규화, 반정규화, 테이블 통합 및 분할, 조인구조, PK/FK 설정 등


- 수행 시점
  - 빠를수록 좋음
    - 분석/설계 단계에서 성능 모델링 수행 -> 재업무 비용 최소화

  - 일반적인 경우
    - 대충 설계 -> 성능 저하 -> 해당 부분만 SQL 튜닝


- 성능 데이터 모델링 진행 순서
  - 정규화를 정확하게 수행
    - 주요 관심사별로 테이블을 분산
   
  - 데이터베이스 용량산정 수행
    - 각 엔터티에 어느정도의 트랜잭션이 들어오는지 파악
   
  - 데이터베이스에 발생되는 트랜잭션의 유형 파악
    - CRUD 매트릭스 활용
   
  - 용량과 트랜잭션의 유형에 따라 반정규화 수행
    - 반정규화 : 정규화의 반대방향에 해당하는 일을 수행하는 것
    - 테이블, 속성, 관계 변경
   
  - 이력모델의 조정, 인덱스를 고려한 PK/FK의 순서 조정, 슈퍼타입/서브타입 조정 등 수행
    - 성능 관점에서 데이터 모델 최종 검증


---

### 02. 관계형 데이터베이스
- DBNS의 발전
  - 1960년대
    - Flowchart 중심의 개발 방법 사용
    - **파일구조**를 통해 데이터를 저장하고 관리
   
  - 1970년대
    - 데이터베이스 관리 기법이 처음 출현
    - **계층형(Hierarchical), 망형(Network)** 데이터베이스 제품 상용화
   
  - 1980년대
    - **관계형(Relational)** 데이터베이스 상용화
    - Oracle, Sybase, DB2 등의 제품 사용
   
  - 1990년대
    - Oracle, Sybase, Informix, DB2, Teradata, SQL Server 의 많은 제품 출현
    - **객체 관계형** 데이터베이스 발전
   

- 관계형 데이터베이스
  - 1970년 영국의 수학자인 E.F Codd 박사의 논문에서 제안 -> 1980년대 상용화
    
  - 기업의 핵심 데이터는 대부분 관계형 데이터베이스로 저장
    
  - 관계형 데이터베이스는 SQL 문장에 의해 관리됨
 
![관계형데이터베이스](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/7fda56e6-8306-4cc8-9a8b-d509e3113131)



- 개요
  - 테이블
 

    ![테이블1](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/23b0fc0e-20ed-45c7-8c39-651ee97254e2)



![테이블2](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/b7215826-1d5c-47fa-8e52-1ba2dca8efb7)



---

### 03. Relational Model Constraints
- 도메인 제약(Domain Constraints)
  - 속성(Attribute)에 대한 제약
  - 속성 값은 원자성(atomicity-더이상 쪼개질 수 없음)을 가지며, 도메인에서 정의된 값이어야 함
  - Composite Attribute와 Multivalued Attribute는 허용되지 않음
    - cf) 주소 = 시군구 + 상세주소
  - Null 값은 허용(Not Null이 아닌 경우)
 
![도메인 제약](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/759e1737-a1fc-40a9-85ad-f6b7f1021a78)




   
- 키 제약(Key Constraints)
  - 릴레이션(Relation)에 대한 제약
  - 릴레이션의 모든 튜플(Tuples)은 서로 식별 가능해야 함(=테이블은 키를 가져야 한다)
  - cf) Super Key, Candidate Key, Primary Key
    : Super Key 중에서 최소성을 갖는 것이 Candidate Key, Candidate Key에서 대표성을 갖는 것이 Primary Key
  - Q) 다음 중 키 제약을 위반하고 있는 릴레이션은?


![기본키 제약](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/aebc5021-f54d-40ca-a060-6449fff22982)



   
- **개체 무결성 제약**(Entity Integrity Constraints)
  - 기본키(Primary Key)에 대한 제약
  - 기본키는 NOT NULL & UNIQUE 이어야 함
  - Q) 다음 중 개체 무결성 제약에 위배되지 않는 튜플은?


![개체무결성 제약](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/f084e7ef-ac8a-4b52-bd86-a6e054094351)



   
- **참조 무경설 제약**(Referential Integrity Constraints)
  - 외래키(Foreign Key)에 대한 제약
    - 릴레이션 R1이 릴레이션 R2를 참조하는 경우, R2의 기본키는 R1에서 외래키로 사용됨
    - FK는 자기 자신이 속한 릴레이션을 참조할 수도 있음

  - 릴레이션 R1이 릴레이션 R2를 참조하는 경우, R1의 FK는
    - Null 이거나
    - Null 이 아닌 경우 R2에 실제로 존재하는 값으로 구성되어야 함

  - Q) 다음 중 참조 무결성을 위배하는 튜플은?


![참조무결성제약](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/f4c3d3bf-f3d2-4ae0-ae39-bd49b7f602e1)


---

### 04. 정규화와 성능
- 이상현상(Anomaly)
DB 설계를 잘못했기 때문에 발생

  - 삭제 이상(delete anomaly)
    - 어떤 정보를 삭제하면서, 의도치않게 다른 정보도 함께 삭제되는 경우
    - '1102' 학생이 'A01'을 수강한 기록을 삭제할 때
      
  - 삽입 이상(insert anomaly)
    - 필수 정보가 비어있기 때문에 원하는 정보를 입력하지 못하는 현상
    - (1004, 윤정한, 010-4444-5555)인 학생을 추가하고자 할 때 -> 과목코드 정보가 없음
      
  - 갱신 이상(update anomaly)
    - 정보를 갱신할 때 여러개를 바꿔야 하는 현상 -> 공간 낭비, 시간 낭비
    - '1101' 학생의 연락처가 변경된 경우 -> 테이블을 분리해두었으면 한번만 변경하면 되지만, 아래 테이블에선 3번이나 변경해야함

      
![이상현상](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/f6fe2dfc-5c25-4d75-8134-d43f176df187)


- 정규화(Normalization)
  - 목적 : 삽입/삭제/갱신 이상현상 방지
    
  - 함수적 종속성(FD, Functional Dependency)에 기반

  - 종류
    - NF(Normal Form, 정규형) : 정규화의 결과로 나오는 것
    - 1NF : 모든 값이 원자값을 가짐
    - 2NF : 부분함수종속(빨간색-PK가 복합키일때만 있을 가능성 있음) 제거
    - 3NF : 이행함수종속(초록색-PK가 아닌 항목이 화살표 쏘는 것) 제거 
    => 식별자가 아닌 속성(주식별자의 일부-부분함수종속 또는 일반속성-이행함수종속)이
        결정자(화살표출발지) 역할을 하는 함수 종속(화살표도착지) 제거 -> 3NF


![함수적 종속성](https://github.com/silverywaves/IT_ACADEMY/assets/155939946/c2fbadec-88e7-4168-b369-b415048e4fe7)



---

  - 효과

